<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.12"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>FairShip: genfit::RKTrackRep Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">FairShip
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.12 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacegenfit.html">genfit</a></li><li class="navelem"><a class="el" href="classgenfit_1_1RKTrackRep.html">RKTrackRep</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classgenfit_1_1RKTrackRep-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">genfit::RKTrackRep Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><a class="el" href="classgenfit_1_1AbsTrackRep.html" title="Abstract base class for a track representation. ">AbsTrackRep</a> with 5D track parameterization in plane coordinates: (q/p, u', v', u, v)  
 <a href="classgenfit_1_1RKTrackRep.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="include_2genfit_2RKTrackRep_8h_source.html">RKTrackRep.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for genfit::RKTrackRep:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classgenfit_1_1RKTrackRep.png" usemap="#genfit::RKTrackRep_map" alt=""/>
  <map id="genfit::RKTrackRep_map" name="genfit::RKTrackRep_map">
<area href="classgenfit_1_1AbsTrackRep.html" title="Abstract base class for a track representation. " alt="genfit::AbsTrackRep" shape="rect" coords="0,56,125,80"/>
<area href="classgenfit_1_1AbsTrackRep.html" title="Abstract base class for a track representation. " alt="genfit::AbsTrackRep" shape="rect" coords="135,56,260,80"/>
</map>
 </div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ab266d184647ad23a4b9f1e8f408b6513"><td class="memItemLeft" align="right" valign="top"><a id="ab266d184647ad23a4b9f1e8f408b6513"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>RKTrackRep</b> (int pdgCode, char propDir=0)</td></tr>
<tr class="separator:ab266d184647ad23a4b9f1e8f408b6513"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb842973c3accd7dce8c10e967fabd14"><td class="memItemLeft" align="right" valign="top"><a id="acb842973c3accd7dce8c10e967fabd14"></a>
virtual <a class="el" href="classgenfit_1_1AbsTrackRep.html">AbsTrackRep</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgenfit_1_1RKTrackRep.html#acb842973c3accd7dce8c10e967fabd14">clone</a> () const</td></tr>
<tr class="memdesc:acb842973c3accd7dce8c10e967fabd14"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clone the trackRep. <br /></td></tr>
<tr class="separator:acb842973c3accd7dce8c10e967fabd14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade2e4cf73880a2df757e9dd372bf7b00"><td class="memItemLeft" align="right" valign="top">virtual double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgenfit_1_1RKTrackRep.html#ade2e4cf73880a2df757e9dd372bf7b00">extrapolateToPlane</a> (<a class="el" href="classgenfit_1_1StateOnPlane.html">StateOnPlane</a> &amp;state, const <a class="el" href="namespacegenfit.html#a53bfc6c64a1fe1c3abea814a500dd60d">SharedPlanePtr</a> &amp;plane, bool stopAtBoundary=false, bool calcJacobianNoise=false) const</td></tr>
<tr class="memdesc:ade2e4cf73880a2df757e9dd372bf7b00"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extrapolates the state to plane, and returns the extrapolation length and, via reference, the extrapolated state.  <a href="#ade2e4cf73880a2df757e9dd372bf7b00">More...</a><br /></td></tr>
<tr class="separator:ade2e4cf73880a2df757e9dd372bf7b00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af556c558f049d00b43b079bd363564d9"><td class="memItemLeft" align="right" valign="top">virtual double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgenfit_1_1RKTrackRep.html#af556c558f049d00b43b079bd363564d9">extrapolateToLine</a> (<a class="el" href="classgenfit_1_1StateOnPlane.html">StateOnPlane</a> &amp;state, const TVector3 &amp;linePoint, const TVector3 &amp;lineDirection, bool stopAtBoundary=false, bool calcJacobianNoise=false) const</td></tr>
<tr class="memdesc:af556c558f049d00b43b079bd363564d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extrapolates the state to the POCA to a line, and returns the extrapolation length and, via reference, the extrapolated state.  <a href="#af556c558f049d00b43b079bd363564d9">More...</a><br /></td></tr>
<tr class="separator:af556c558f049d00b43b079bd363564d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb99d5a9c3b53087dfbd30cb1d393eaa"><td class="memItemLeft" align="right" valign="top">virtual double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgenfit_1_1RKTrackRep.html#afb99d5a9c3b53087dfbd30cb1d393eaa">extrapolateToPoint</a> (<a class="el" href="classgenfit_1_1StateOnPlane.html">StateOnPlane</a> &amp;state, const TVector3 &amp;point, bool stopAtBoundary=false, bool calcJacobianNoise=false) const</td></tr>
<tr class="memdesc:afb99d5a9c3b53087dfbd30cb1d393eaa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extrapolates the state to the POCA to a point, and returns the extrapolation length and, via reference, the extrapolated state.  <a href="#afb99d5a9c3b53087dfbd30cb1d393eaa">More...</a><br /></td></tr>
<tr class="separator:afb99d5a9c3b53087dfbd30cb1d393eaa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add04b97a56a22832fed2a96bfa45a597"><td class="memItemLeft" align="right" valign="top">virtual double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgenfit_1_1RKTrackRep.html#add04b97a56a22832fed2a96bfa45a597">extrapolateToPoint</a> (<a class="el" href="classgenfit_1_1StateOnPlane.html">StateOnPlane</a> &amp;state, const TVector3 &amp;point, const TMatrixDSym &amp;G, bool stopAtBoundary=false, bool calcJacobianNoise=false) const</td></tr>
<tr class="memdesc:add04b97a56a22832fed2a96bfa45a597"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extrapolates the state to the POCA to a point in the metric of G, and returns the extrapolation length and, via reference, the extrapolated state.  <a href="#add04b97a56a22832fed2a96bfa45a597">More...</a><br /></td></tr>
<tr class="separator:add04b97a56a22832fed2a96bfa45a597"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7cfb69ae23f997f00073c2178771e233"><td class="memItemLeft" align="right" valign="top">virtual double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgenfit_1_1RKTrackRep.html#a7cfb69ae23f997f00073c2178771e233">extrapolateToCylinder</a> (<a class="el" href="classgenfit_1_1StateOnPlane.html">StateOnPlane</a> &amp;state, double radius, const TVector3 &amp;linePoint=TVector3(0., 0., 0.), const TVector3 &amp;lineDirection=TVector3(0., 0., 1.), bool stopAtBoundary=false, bool calcJacobianNoise=false) const</td></tr>
<tr class="memdesc:a7cfb69ae23f997f00073c2178771e233"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extrapolates the state to the cylinder surface, and returns the extrapolation length and, via reference, the extrapolated state.  <a href="#a7cfb69ae23f997f00073c2178771e233">More...</a><br /></td></tr>
<tr class="separator:a7cfb69ae23f997f00073c2178771e233"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a593518bed9f4385feab1623a66d734a5"><td class="memItemLeft" align="right" valign="top">virtual double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgenfit_1_1RKTrackRep.html#a593518bed9f4385feab1623a66d734a5">extrapolateToSphere</a> (<a class="el" href="classgenfit_1_1StateOnPlane.html">StateOnPlane</a> &amp;state, double radius, const TVector3 &amp;point=TVector3(0., 0., 0.), bool stopAtBoundary=false, bool calcJacobianNoise=false) const</td></tr>
<tr class="memdesc:a593518bed9f4385feab1623a66d734a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extrapolates the state to the sphere surface, and returns the extrapolation length and, via reference, the extrapolated state.  <a href="#a593518bed9f4385feab1623a66d734a5">More...</a><br /></td></tr>
<tr class="separator:a593518bed9f4385feab1623a66d734a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e8225094b2cba938c3dcef7261ccfb0"><td class="memItemLeft" align="right" valign="top">virtual double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgenfit_1_1RKTrackRep.html#a6e8225094b2cba938c3dcef7261ccfb0">extrapolateBy</a> (<a class="el" href="classgenfit_1_1StateOnPlane.html">StateOnPlane</a> &amp;state, double step, bool stopAtBoundary=false, bool calcJacobianNoise=false) const</td></tr>
<tr class="memdesc:a6e8225094b2cba938c3dcef7261ccfb0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extrapolates the state by step (cm) and returns the extrapolation length and, via reference, the extrapolated state.  <a href="#a6e8225094b2cba938c3dcef7261ccfb0">More...</a><br /></td></tr>
<tr class="separator:a6e8225094b2cba938c3dcef7261ccfb0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9fb36a12c29b84f73fe2243f65ae09b7"><td class="memItemLeft" align="right" valign="top"><a id="a9fb36a12c29b84f73fe2243f65ae09b7"></a>
unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgenfit_1_1RKTrackRep.html#a9fb36a12c29b84f73fe2243f65ae09b7">getDim</a> () const</td></tr>
<tr class="memdesc:a9fb36a12c29b84f73fe2243f65ae09b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the dimension of the state vector used by the track representation. <br /></td></tr>
<tr class="separator:a9fb36a12c29b84f73fe2243f65ae09b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf4865558fe7b54ffe94c3e145344505"><td class="memItemLeft" align="right" valign="top"><a id="adf4865558fe7b54ffe94c3e145344505"></a>
virtual TVector3&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgenfit_1_1RKTrackRep.html#adf4865558fe7b54ffe94c3e145344505">getPos</a> (const <a class="el" href="classgenfit_1_1StateOnPlane.html">StateOnPlane</a> &amp;state) const</td></tr>
<tr class="memdesc:adf4865558fe7b54ffe94c3e145344505"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the cartesian position of a state. <br /></td></tr>
<tr class="separator:adf4865558fe7b54ffe94c3e145344505"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01ccd6e74c4750e434e89992e853ae30"><td class="memItemLeft" align="right" valign="top"><a id="a01ccd6e74c4750e434e89992e853ae30"></a>
virtual TVector3&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgenfit_1_1RKTrackRep.html#a01ccd6e74c4750e434e89992e853ae30">getMom</a> (const <a class="el" href="classgenfit_1_1StateOnPlane.html">StateOnPlane</a> &amp;state) const</td></tr>
<tr class="memdesc:a01ccd6e74c4750e434e89992e853ae30"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the cartesian momentum vector of a state. <br /></td></tr>
<tr class="separator:a01ccd6e74c4750e434e89992e853ae30"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35723de16e1bae56aeb8a7ca098b2b9e"><td class="memItemLeft" align="right" valign="top"><a id="a35723de16e1bae56aeb8a7ca098b2b9e"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgenfit_1_1RKTrackRep.html#a35723de16e1bae56aeb8a7ca098b2b9e">getPosMom</a> (const <a class="el" href="classgenfit_1_1StateOnPlane.html">StateOnPlane</a> &amp;state, TVector3 &amp;pos, TVector3 &amp;mom) const</td></tr>
<tr class="memdesc:a35723de16e1bae56aeb8a7ca098b2b9e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get cartesian position and momentum vector of a state. <br /></td></tr>
<tr class="separator:a35723de16e1bae56aeb8a7ca098b2b9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7f24c1004c5693d405225be56ec007c"><td class="memItemLeft" align="right" valign="top"><a id="ab7f24c1004c5693d405225be56ec007c"></a>
virtual double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgenfit_1_1RKTrackRep.html#ab7f24c1004c5693d405225be56ec007c">getMomMag</a> (const <a class="el" href="classgenfit_1_1StateOnPlane.html">StateOnPlane</a> &amp;state) const</td></tr>
<tr class="memdesc:ab7f24c1004c5693d405225be56ec007c"><td class="mdescLeft">&#160;</td><td class="mdescRight">get the magnitude of the momentum in GeV. <br /></td></tr>
<tr class="separator:ab7f24c1004c5693d405225be56ec007c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0993fd7e2150032f83508291c9aa713"><td class="memItemLeft" align="right" valign="top"><a id="ab0993fd7e2150032f83508291c9aa713"></a>
virtual double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgenfit_1_1RKTrackRep.html#ab0993fd7e2150032f83508291c9aa713">getMomVar</a> (const <a class="el" href="classgenfit_1_1MeasuredStateOnPlane.html">MeasuredStateOnPlane</a> &amp;state) const</td></tr>
<tr class="memdesc:ab0993fd7e2150032f83508291c9aa713"><td class="mdescLeft">&#160;</td><td class="mdescRight">get the variance of the absolute value of the momentum . <br /></td></tr>
<tr class="separator:ab0993fd7e2150032f83508291c9aa713"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e880395d30a6520d8a9aece5f0e36b3"><td class="memItemLeft" align="right" valign="top"><a id="a5e880395d30a6520d8a9aece5f0e36b3"></a>
virtual TMatrixDSym&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgenfit_1_1RKTrackRep.html#a5e880395d30a6520d8a9aece5f0e36b3">get6DCov</a> (const <a class="el" href="classgenfit_1_1MeasuredStateOnPlane.html">MeasuredStateOnPlane</a> &amp;state) const</td></tr>
<tr class="memdesc:a5e880395d30a6520d8a9aece5f0e36b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the 6D covariance. <br /></td></tr>
<tr class="separator:a5e880395d30a6520d8a9aece5f0e36b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad94153c3713eeff5ee143ab21902de62"><td class="memItemLeft" align="right" valign="top"><a id="ad94153c3713eeff5ee143ab21902de62"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgenfit_1_1RKTrackRep.html#ad94153c3713eeff5ee143ab21902de62">getPosMomCov</a> (const <a class="el" href="classgenfit_1_1MeasuredStateOnPlane.html">MeasuredStateOnPlane</a> &amp;state, TVector3 &amp;pos, TVector3 &amp;mom, TMatrixDSym &amp;cov) const</td></tr>
<tr class="memdesc:ad94153c3713eeff5ee143ab21902de62"><td class="mdescLeft">&#160;</td><td class="mdescRight">Translates <a class="el" href="classgenfit_1_1MeasuredStateOnPlane.html" title="#StateOnPlane with additional covariance matrix. ">MeasuredStateOnPlane</a> into 3D position, momentum and 6x6 covariance. <br /></td></tr>
<tr class="separator:ad94153c3713eeff5ee143ab21902de62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33b8c25c6a34f361839aa7ac65769193"><td class="memItemLeft" align="right" valign="top"><a id="a33b8c25c6a34f361839aa7ac65769193"></a>
virtual double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgenfit_1_1RKTrackRep.html#a33b8c25c6a34f361839aa7ac65769193">getCharge</a> (const <a class="el" href="classgenfit_1_1StateOnPlane.html">StateOnPlane</a> &amp;state) const</td></tr>
<tr class="memdesc:a33b8c25c6a34f361839aa7ac65769193"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the (fitted) charge of a state. This is not always equal the pdg charge (e.g. if the charge sign was flipped during the fit). <br /></td></tr>
<tr class="separator:a33b8c25c6a34f361839aa7ac65769193"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a57b696edac7ed33608d10053f255d6"><td class="memItemLeft" align="right" valign="top"><a id="a2a57b696edac7ed33608d10053f255d6"></a>
virtual double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgenfit_1_1RKTrackRep.html#a2a57b696edac7ed33608d10053f255d6">getQop</a> (const <a class="el" href="classgenfit_1_1StateOnPlane.html">StateOnPlane</a> &amp;state) const</td></tr>
<tr class="memdesc:a2a57b696edac7ed33608d10053f255d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get charge over momentum. <br /></td></tr>
<tr class="separator:a2a57b696edac7ed33608d10053f255d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a177f273f4dc3d7d1eaa646fe5a70aaf3"><td class="memItemLeft" align="right" valign="top"><a id="a177f273f4dc3d7d1eaa646fe5a70aaf3"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><b>getSpu</b> (const <a class="el" href="classgenfit_1_1StateOnPlane.html">StateOnPlane</a> &amp;state) const</td></tr>
<tr class="separator:a177f273f4dc3d7d1eaa646fe5a70aaf3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa96520234a875b14591c79214627c50c"><td class="memItemLeft" align="right" valign="top"><a id="aa96520234a875b14591c79214627c50c"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgenfit_1_1RKTrackRep.html#aa96520234a875b14591c79214627c50c">getForwardJacobianAndNoise</a> (TMatrixD &amp;jacobian, TMatrixDSym &amp;noise, TVectorD &amp;deltaState) const</td></tr>
<tr class="memdesc:aa96520234a875b14591c79214627c50c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the jacobian and noise matrix of the last extrapolation. <br /></td></tr>
<tr class="separator:aa96520234a875b14591c79214627c50c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b4f84851dbb33f617a52f9bbd3ccd8a"><td class="memItemLeft" align="right" valign="top"><a id="a1b4f84851dbb33f617a52f9bbd3ccd8a"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgenfit_1_1RKTrackRep.html#a1b4f84851dbb33f617a52f9bbd3ccd8a">getBackwardJacobianAndNoise</a> (TMatrixD &amp;jacobian, TMatrixDSym &amp;noise, TVectorD &amp;deltaState) const</td></tr>
<tr class="memdesc:a1b4f84851dbb33f617a52f9bbd3ccd8a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the jacobian and noise matrix of the last extrapolation if it would have been done in opposite direction. <br /></td></tr>
<tr class="separator:a1b4f84851dbb33f617a52f9bbd3ccd8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71750034f38aa93a3941ae3ae3d3533e"><td class="memItemLeft" align="right" valign="top"><a id="a71750034f38aa93a3941ae3ae3d3533e"></a>
std::vector&lt; <a class="el" href="structgenfit_1_1MatStep.html">genfit::MatStep</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgenfit_1_1RKTrackRep.html#a71750034f38aa93a3941ae3ae3d3533e">getSteps</a> () const</td></tr>
<tr class="memdesc:a71750034f38aa93a3941ae3ae3d3533e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get stepsizes and material properties of crossed materials of the last extrapolation. <br /></td></tr>
<tr class="separator:a71750034f38aa93a3941ae3ae3d3533e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaaaf31bac6cfa342cfb5560ec2f1f3d0"><td class="memItemLeft" align="right" valign="top"><a id="aaaaf31bac6cfa342cfb5560ec2f1f3d0"></a>
virtual double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgenfit_1_1RKTrackRep.html#aaaaf31bac6cfa342cfb5560ec2f1f3d0">getRadiationLenght</a> () const</td></tr>
<tr class="memdesc:aaaaf31bac6cfa342cfb5560ec2f1f3d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the accumulated X/X0 (path / radiation length) of the material crossed in the last extrapolation. <br /></td></tr>
<tr class="separator:aaaaf31bac6cfa342cfb5560ec2f1f3d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78bd680b2fee363204b524fe76f988b9"><td class="memItemLeft" align="right" valign="top"><a id="a78bd680b2fee363204b524fe76f988b9"></a>
virtual double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgenfit_1_1RKTrackRep.html#a78bd680b2fee363204b524fe76f988b9">getTOF</a> () const</td></tr>
<tr class="memdesc:a78bd680b2fee363204b524fe76f988b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the time of flight [ns] of the last extrapolation. <br /></td></tr>
<tr class="separator:a78bd680b2fee363204b524fe76f988b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a743ae73c90b306147fff6092ae2a0c99"><td class="memItemLeft" align="right" valign="top"><a id="a743ae73c90b306147fff6092ae2a0c99"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgenfit_1_1RKTrackRep.html#a743ae73c90b306147fff6092ae2a0c99">setPosMom</a> (<a class="el" href="classgenfit_1_1StateOnPlane.html">StateOnPlane</a> &amp;state, const TVector3 &amp;pos, const TVector3 &amp;mom) const</td></tr>
<tr class="memdesc:a743ae73c90b306147fff6092ae2a0c99"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set position and momentum of state. <br /></td></tr>
<tr class="separator:a743ae73c90b306147fff6092ae2a0c99"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a4f43ee1ff3f76f0f6cdf1b02cfacde"><td class="memItemLeft" align="right" valign="top"><a id="a5a4f43ee1ff3f76f0f6cdf1b02cfacde"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgenfit_1_1RKTrackRep.html#a5a4f43ee1ff3f76f0f6cdf1b02cfacde">setPosMom</a> (<a class="el" href="classgenfit_1_1StateOnPlane.html">StateOnPlane</a> &amp;state, const TVectorD &amp;state6) const</td></tr>
<tr class="memdesc:a5a4f43ee1ff3f76f0f6cdf1b02cfacde"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set position and momentum of state. <br /></td></tr>
<tr class="separator:a5a4f43ee1ff3f76f0f6cdf1b02cfacde"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e3336e902f6edb35dce5205724cfb1b"><td class="memItemLeft" align="right" valign="top"><a id="a0e3336e902f6edb35dce5205724cfb1b"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgenfit_1_1RKTrackRep.html#a0e3336e902f6edb35dce5205724cfb1b">setPosMomErr</a> (<a class="el" href="classgenfit_1_1MeasuredStateOnPlane.html">MeasuredStateOnPlane</a> &amp;state, const TVector3 &amp;pos, const TVector3 &amp;mom, const TVector3 &amp;posErr, const TVector3 &amp;momErr) const</td></tr>
<tr class="memdesc:a0e3336e902f6edb35dce5205724cfb1b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set position and momentum and error of state. <br /></td></tr>
<tr class="separator:a0e3336e902f6edb35dce5205724cfb1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a0c5a51469f0400049001c287ddd516"><td class="memItemLeft" align="right" valign="top"><a id="a9a0c5a51469f0400049001c287ddd516"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgenfit_1_1RKTrackRep.html#a9a0c5a51469f0400049001c287ddd516">setPosMomCov</a> (<a class="el" href="classgenfit_1_1MeasuredStateOnPlane.html">MeasuredStateOnPlane</a> &amp;state, const TVector3 &amp;pos, const TVector3 &amp;mom, const TMatrixDSym &amp;cov6x6) const</td></tr>
<tr class="memdesc:a9a0c5a51469f0400049001c287ddd516"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set position, momentum and covariance of state. <br /></td></tr>
<tr class="separator:a9a0c5a51469f0400049001c287ddd516"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adda4fd1cb09adcd30afff0594e24519d"><td class="memItemLeft" align="right" valign="top"><a id="adda4fd1cb09adcd30afff0594e24519d"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgenfit_1_1RKTrackRep.html#adda4fd1cb09adcd30afff0594e24519d">setPosMomCov</a> (<a class="el" href="classgenfit_1_1MeasuredStateOnPlane.html">MeasuredStateOnPlane</a> &amp;state, const TVectorD &amp;state6, const TMatrixDSym &amp;cov6x6) const</td></tr>
<tr class="memdesc:adda4fd1cb09adcd30afff0594e24519d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set position, momentum and covariance of state. <br /></td></tr>
<tr class="separator:adda4fd1cb09adcd30afff0594e24519d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23f160ca573dbf0ed2526b2c21b1fdc2"><td class="memItemLeft" align="right" valign="top"><a id="a23f160ca573dbf0ed2526b2c21b1fdc2"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgenfit_1_1RKTrackRep.html#a23f160ca573dbf0ed2526b2c21b1fdc2">setChargeSign</a> (<a class="el" href="classgenfit_1_1StateOnPlane.html">StateOnPlane</a> &amp;state, double charge) const</td></tr>
<tr class="memdesc:a23f160ca573dbf0ed2526b2c21b1fdc2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the sign of the charge according to charge. <br /></td></tr>
<tr class="separator:a23f160ca573dbf0ed2526b2c21b1fdc2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1eb48cd7c3e1c5d954563cea4d37576d"><td class="memItemLeft" align="right" valign="top"><a id="a1eb48cd7c3e1c5d954563cea4d37576d"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgenfit_1_1RKTrackRep.html#a1eb48cd7c3e1c5d954563cea4d37576d">setQop</a> (<a class="el" href="classgenfit_1_1StateOnPlane.html">StateOnPlane</a> &amp;state, double qop) const</td></tr>
<tr class="memdesc:a1eb48cd7c3e1c5d954563cea4d37576d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set charge/momentum. <br /></td></tr>
<tr class="separator:a1eb48cd7c3e1c5d954563cea4d37576d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a324ba092d634f324285f445b4bba12b6"><td class="memItemLeft" align="right" valign="top"><a id="a324ba092d634f324285f445b4bba12b6"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>setSpu</b> (<a class="el" href="classgenfit_1_1StateOnPlane.html">StateOnPlane</a> &amp;state, double spu) const</td></tr>
<tr class="separator:a324ba092d634f324285f445b4bba12b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:affa6945eaba3b0f2b143d039967b834e"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgenfit_1_1RKTrackRep.html#affa6945eaba3b0f2b143d039967b834e">RKPropagate</a> (M1x7 &amp;state7, M7x7 *jacobian, <a class="el" href="namespacegenfit.html#a3e8167b2b78ea4a8f7d5f6485640a6cd">M1x3</a> &amp;SA, double S, bool varField=true, bool calcOnlyLastRowOfJ=false) const</td></tr>
<tr class="memdesc:affa6945eaba3b0f2b143d039967b834e"><td class="mdescLeft">&#160;</td><td class="mdescRight">The actual Runge Kutta propagation.  <a href="#affa6945eaba3b0f2b143d039967b834e">More...</a><br /></td></tr>
<tr class="separator:affa6945eaba3b0f2b143d039967b834e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8e39563fac26c69d88f3408ba6de39e"><td class="memItemLeft" align="right" valign="top"><a id="ae8e39563fac26c69d88f3408ba6de39e"></a>
virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgenfit_1_1RKTrackRep.html#ae8e39563fac26c69d88f3408ba6de39e">isSameType</a> (const <a class="el" href="classgenfit_1_1AbsTrackRep.html">AbsTrackRep</a> *other)</td></tr>
<tr class="memdesc:ae8e39563fac26c69d88f3408ba6de39e"><td class="mdescLeft">&#160;</td><td class="mdescRight">check if other is of same type (e.g. <a class="el" href="classgenfit_1_1RKTrackRep.html" title="AbsTrackRep with 5D track parameterization in plane coordinates: (q/p, u&#39;, v&#39;, u, v) ...">RKTrackRep</a>). <br /></td></tr>
<tr class="separator:ae8e39563fac26c69d88f3408ba6de39e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8ca7fc3eb20ddf0e8712b6a1f720356"><td class="memItemLeft" align="right" valign="top"><a id="aa8ca7fc3eb20ddf0e8712b6a1f720356"></a>
virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgenfit_1_1RKTrackRep.html#aa8ca7fc3eb20ddf0e8712b6a1f720356">isSame</a> (const <a class="el" href="classgenfit_1_1AbsTrackRep.html">AbsTrackRep</a> *other)</td></tr>
<tr class="memdesc:aa8ca7fc3eb20ddf0e8712b6a1f720356"><td class="mdescLeft">&#160;</td><td class="mdescRight">check if other is of same type (e.g. <a class="el" href="classgenfit_1_1RKTrackRep.html" title="AbsTrackRep with 5D track parameterization in plane coordinates: (q/p, u&#39;, v&#39;, u, v) ...">RKTrackRep</a>) and has same pdg code. <br /></td></tr>
<tr class="separator:aa8ca7fc3eb20ddf0e8712b6a1f720356"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab266d184647ad23a4b9f1e8f408b6513"><td class="memItemLeft" align="right" valign="top"><a id="ab266d184647ad23a4b9f1e8f408b6513"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>RKTrackRep</b> (int pdgCode, char propDir=0)</td></tr>
<tr class="separator:ab266d184647ad23a4b9f1e8f408b6513"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb842973c3accd7dce8c10e967fabd14"><td class="memItemLeft" align="right" valign="top"><a id="acb842973c3accd7dce8c10e967fabd14"></a>
virtual <a class="el" href="classgenfit_1_1AbsTrackRep.html">AbsTrackRep</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgenfit_1_1RKTrackRep.html#acb842973c3accd7dce8c10e967fabd14">clone</a> () const</td></tr>
<tr class="memdesc:acb842973c3accd7dce8c10e967fabd14"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clone the trackRep. <br /></td></tr>
<tr class="separator:acb842973c3accd7dce8c10e967fabd14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43755174182fc4f0e42cae45b690baae"><td class="memItemLeft" align="right" valign="top">virtual double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgenfit_1_1RKTrackRep.html#a43755174182fc4f0e42cae45b690baae">extrapolateToPlane</a> (<a class="el" href="classgenfit_1_1StateOnPlane.html">StateOnPlane</a> &amp;state, const <a class="el" href="namespacegenfit.html#a53bfc6c64a1fe1c3abea814a500dd60d">SharedPlanePtr</a> &amp;plane, bool stopAtBoundary=false, bool calcJacobianNoise=false) const</td></tr>
<tr class="memdesc:a43755174182fc4f0e42cae45b690baae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extrapolates the state to plane, and returns the extrapolation length and, via reference, the extrapolated state.  <a href="#a43755174182fc4f0e42cae45b690baae">More...</a><br /></td></tr>
<tr class="separator:a43755174182fc4f0e42cae45b690baae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add17267d625d78c2df112bbf501f5753"><td class="memItemLeft" align="right" valign="top"><a id="add17267d625d78c2df112bbf501f5753"></a>
virtual double&#160;</td><td class="memItemRight" valign="bottom"><b>extrapolateToPlane</b> (<a class="el" href="classgenfit_1_1StateOnPlane.html">StateOnPlane</a> &amp;state, const TVector3 &amp;point, const TVector3 &amp;dir, bool stopAtBoundary=false, bool calcJacobianNoise=false) const</td></tr>
<tr class="separator:add17267d625d78c2df112bbf501f5753"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afeebe12bb8b5385b4ed46258271e7f13"><td class="memItemLeft" align="right" valign="top">virtual double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgenfit_1_1RKTrackRep.html#afeebe12bb8b5385b4ed46258271e7f13">extrapolateToLine</a> (<a class="el" href="classgenfit_1_1StateOnPlane.html">StateOnPlane</a> &amp;state, const TVector3 &amp;linePoint, const TVector3 &amp;lineDirection, bool stopAtBoundary=false, bool calcJacobianNoise=false) const</td></tr>
<tr class="memdesc:afeebe12bb8b5385b4ed46258271e7f13"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extrapolates the state to the POCA to a line, and returns the extrapolation length and, via reference, the extrapolated state.  <a href="#afeebe12bb8b5385b4ed46258271e7f13">More...</a><br /></td></tr>
<tr class="separator:afeebe12bb8b5385b4ed46258271e7f13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb99d5a9c3b53087dfbd30cb1d393eaa"><td class="memItemLeft" align="right" valign="top">virtual double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgenfit_1_1RKTrackRep.html#afb99d5a9c3b53087dfbd30cb1d393eaa">extrapolateToPoint</a> (<a class="el" href="classgenfit_1_1StateOnPlane.html">StateOnPlane</a> &amp;state, const TVector3 &amp;point, bool stopAtBoundary=false, bool calcJacobianNoise=false) const</td></tr>
<tr class="memdesc:afb99d5a9c3b53087dfbd30cb1d393eaa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extrapolates the state to the POCA to a point, and returns the extrapolation length and, via reference, the extrapolated state.  <a href="#afb99d5a9c3b53087dfbd30cb1d393eaa">More...</a><br /></td></tr>
<tr class="separator:afb99d5a9c3b53087dfbd30cb1d393eaa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add04b97a56a22832fed2a96bfa45a597"><td class="memItemLeft" align="right" valign="top">virtual double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgenfit_1_1RKTrackRep.html#add04b97a56a22832fed2a96bfa45a597">extrapolateToPoint</a> (<a class="el" href="classgenfit_1_1StateOnPlane.html">StateOnPlane</a> &amp;state, const TVector3 &amp;point, const TMatrixDSym &amp;G, bool stopAtBoundary=false, bool calcJacobianNoise=false) const</td></tr>
<tr class="memdesc:add04b97a56a22832fed2a96bfa45a597"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extrapolates the state to the POCA to a point in the metric of G, and returns the extrapolation length and, via reference, the extrapolated state.  <a href="#add04b97a56a22832fed2a96bfa45a597">More...</a><br /></td></tr>
<tr class="separator:add04b97a56a22832fed2a96bfa45a597"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa91d6caaf330881eead525c66dff955f"><td class="memItemLeft" align="right" valign="top">virtual double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgenfit_1_1RKTrackRep.html#aa91d6caaf330881eead525c66dff955f">extrapolateToCylinder</a> (<a class="el" href="classgenfit_1_1StateOnPlane.html">StateOnPlane</a> &amp;state, double radius, const TVector3 &amp;linePoint=TVector3(0., 0., 0.), const TVector3 &amp;lineDirection=TVector3(0., 0., 1.), bool stopAtBoundary=false, bool calcJacobianNoise=false) const</td></tr>
<tr class="memdesc:aa91d6caaf330881eead525c66dff955f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extrapolates the state to the cylinder surface, and returns the extrapolation length and, via reference, the extrapolated state.  <a href="#aa91d6caaf330881eead525c66dff955f">More...</a><br /></td></tr>
<tr class="separator:aa91d6caaf330881eead525c66dff955f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72111e10145836e1357cf6fa1aa59b63"><td class="memItemLeft" align="right" valign="top">virtual double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgenfit_1_1RKTrackRep.html#a72111e10145836e1357cf6fa1aa59b63">extrapolateToSphere</a> (<a class="el" href="classgenfit_1_1StateOnPlane.html">StateOnPlane</a> &amp;state, double radius, const TVector3 &amp;point=TVector3(0., 0., 0.), bool stopAtBoundary=false, bool calcJacobianNoise=false) const</td></tr>
<tr class="memdesc:a72111e10145836e1357cf6fa1aa59b63"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extrapolates the state to the sphere surface, and returns the extrapolation length and, via reference, the extrapolated state.  <a href="#a72111e10145836e1357cf6fa1aa59b63">More...</a><br /></td></tr>
<tr class="separator:a72111e10145836e1357cf6fa1aa59b63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f4323fd5ad69bce79d82d0af287417e"><td class="memItemLeft" align="right" valign="top">virtual double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgenfit_1_1RKTrackRep.html#a4f4323fd5ad69bce79d82d0af287417e">extrapolateBy</a> (<a class="el" href="classgenfit_1_1StateOnPlane.html">StateOnPlane</a> &amp;state, double step, bool stopAtBoundary=false, bool calcJacobianNoise=false) const</td></tr>
<tr class="memdesc:a4f4323fd5ad69bce79d82d0af287417e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extrapolates the state by step (cm) and returns the extrapolation length and, via reference, the extrapolated state.  <a href="#a4f4323fd5ad69bce79d82d0af287417e">More...</a><br /></td></tr>
<tr class="separator:a4f4323fd5ad69bce79d82d0af287417e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9fb36a12c29b84f73fe2243f65ae09b7"><td class="memItemLeft" align="right" valign="top"><a id="a9fb36a12c29b84f73fe2243f65ae09b7"></a>
unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgenfit_1_1RKTrackRep.html#a9fb36a12c29b84f73fe2243f65ae09b7">getDim</a> () const</td></tr>
<tr class="memdesc:a9fb36a12c29b84f73fe2243f65ae09b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the dimension of the state vector used by the track representation. <br /></td></tr>
<tr class="separator:a9fb36a12c29b84f73fe2243f65ae09b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8043122392aed738fa1596b74cfa957"><td class="memItemLeft" align="right" valign="top"><a id="af8043122392aed738fa1596b74cfa957"></a>
virtual TVector3&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgenfit_1_1RKTrackRep.html#af8043122392aed738fa1596b74cfa957">getPos</a> (const <a class="el" href="classgenfit_1_1StateOnPlane.html">StateOnPlane</a> &amp;state) const</td></tr>
<tr class="memdesc:af8043122392aed738fa1596b74cfa957"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the cartesian position of a state. <br /></td></tr>
<tr class="separator:af8043122392aed738fa1596b74cfa957"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac729ee4957d43f4531f7621599286bbf"><td class="memItemLeft" align="right" valign="top"><a id="ac729ee4957d43f4531f7621599286bbf"></a>
virtual TVector3&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgenfit_1_1RKTrackRep.html#ac729ee4957d43f4531f7621599286bbf">getMom</a> (const <a class="el" href="classgenfit_1_1StateOnPlane.html">StateOnPlane</a> &amp;state) const</td></tr>
<tr class="memdesc:ac729ee4957d43f4531f7621599286bbf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the cartesian momentum vector of a state. <br /></td></tr>
<tr class="separator:ac729ee4957d43f4531f7621599286bbf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aece5f6f41109186ac8116a1311c2c702"><td class="memItemLeft" align="right" valign="top"><a id="aece5f6f41109186ac8116a1311c2c702"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgenfit_1_1RKTrackRep.html#aece5f6f41109186ac8116a1311c2c702">getPosMom</a> (const <a class="el" href="classgenfit_1_1StateOnPlane.html">StateOnPlane</a> &amp;state, TVector3 &amp;pos, TVector3 &amp;mom) const</td></tr>
<tr class="memdesc:aece5f6f41109186ac8116a1311c2c702"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get cartesian position and momentum vector of a state. <br /></td></tr>
<tr class="separator:aece5f6f41109186ac8116a1311c2c702"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2dc54584a27cddd473186cea5e23206"><td class="memItemLeft" align="right" valign="top"><a id="af2dc54584a27cddd473186cea5e23206"></a>
virtual double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgenfit_1_1RKTrackRep.html#af2dc54584a27cddd473186cea5e23206">getMomMag</a> (const <a class="el" href="classgenfit_1_1StateOnPlane.html">StateOnPlane</a> &amp;state) const</td></tr>
<tr class="memdesc:af2dc54584a27cddd473186cea5e23206"><td class="mdescLeft">&#160;</td><td class="mdescRight">get the magnitude of the momentum in GeV. <br /></td></tr>
<tr class="separator:af2dc54584a27cddd473186cea5e23206"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82d4e2aca5f1636f0d8a21ac099f69b0"><td class="memItemLeft" align="right" valign="top"><a id="a82d4e2aca5f1636f0d8a21ac099f69b0"></a>
virtual double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgenfit_1_1RKTrackRep.html#a82d4e2aca5f1636f0d8a21ac099f69b0">getMomVar</a> (const <a class="el" href="classgenfit_1_1MeasuredStateOnPlane.html">MeasuredStateOnPlane</a> &amp;state) const</td></tr>
<tr class="memdesc:a82d4e2aca5f1636f0d8a21ac099f69b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">get the variance of the absolute value of the momentum . <br /></td></tr>
<tr class="separator:a82d4e2aca5f1636f0d8a21ac099f69b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd3b926fefc365621ce79d2e13b7be7c"><td class="memItemLeft" align="right" valign="top"><a id="afd3b926fefc365621ce79d2e13b7be7c"></a>
virtual TMatrixDSym&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgenfit_1_1RKTrackRep.html#afd3b926fefc365621ce79d2e13b7be7c">get6DCov</a> (const <a class="el" href="classgenfit_1_1MeasuredStateOnPlane.html">MeasuredStateOnPlane</a> &amp;state) const</td></tr>
<tr class="memdesc:afd3b926fefc365621ce79d2e13b7be7c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the 6D covariance. <br /></td></tr>
<tr class="separator:afd3b926fefc365621ce79d2e13b7be7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a365af2b96444bab71d5acb3cd75318c3"><td class="memItemLeft" align="right" valign="top"><a id="a365af2b96444bab71d5acb3cd75318c3"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgenfit_1_1RKTrackRep.html#a365af2b96444bab71d5acb3cd75318c3">getPosMomCov</a> (const <a class="el" href="classgenfit_1_1MeasuredStateOnPlane.html">MeasuredStateOnPlane</a> &amp;state, TVector3 &amp;pos, TVector3 &amp;mom, TMatrixDSym &amp;cov) const</td></tr>
<tr class="memdesc:a365af2b96444bab71d5acb3cd75318c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Translates <a class="el" href="classgenfit_1_1MeasuredStateOnPlane.html" title="#StateOnPlane with additional covariance matrix. ">MeasuredStateOnPlane</a> into 3D position, momentum and 6x6 covariance. <br /></td></tr>
<tr class="separator:a365af2b96444bab71d5acb3cd75318c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8213288fbf4d7b25e02b6a49440702a9"><td class="memItemLeft" align="right" valign="top"><a id="a8213288fbf4d7b25e02b6a49440702a9"></a>
virtual double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgenfit_1_1RKTrackRep.html#a8213288fbf4d7b25e02b6a49440702a9">getCharge</a> (const <a class="el" href="classgenfit_1_1StateOnPlane.html">StateOnPlane</a> &amp;state) const</td></tr>
<tr class="memdesc:a8213288fbf4d7b25e02b6a49440702a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the (fitted) charge of a state. This is not always equal the pdg charge (e.g. if the charge sign was flipped during the fit). <br /></td></tr>
<tr class="separator:a8213288fbf4d7b25e02b6a49440702a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a57b696edac7ed33608d10053f255d6"><td class="memItemLeft" align="right" valign="top"><a id="a2a57b696edac7ed33608d10053f255d6"></a>
virtual double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgenfit_1_1RKTrackRep.html#a2a57b696edac7ed33608d10053f255d6">getQop</a> (const <a class="el" href="classgenfit_1_1StateOnPlane.html">StateOnPlane</a> &amp;state) const</td></tr>
<tr class="memdesc:a2a57b696edac7ed33608d10053f255d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get charge over momentum. <br /></td></tr>
<tr class="separator:a2a57b696edac7ed33608d10053f255d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a177f273f4dc3d7d1eaa646fe5a70aaf3"><td class="memItemLeft" align="right" valign="top"><a id="a177f273f4dc3d7d1eaa646fe5a70aaf3"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><b>getSpu</b> (const <a class="el" href="classgenfit_1_1StateOnPlane.html">StateOnPlane</a> &amp;state) const</td></tr>
<tr class="separator:a177f273f4dc3d7d1eaa646fe5a70aaf3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a100bb8b3cd47c4f13fb3fc8e044a1980"><td class="memItemLeft" align="right" valign="top"><a id="a100bb8b3cd47c4f13fb3fc8e044a1980"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgenfit_1_1RKTrackRep.html#a100bb8b3cd47c4f13fb3fc8e044a1980">getForwardJacobianAndNoise</a> (TMatrixD &amp;jacobian, TMatrixDSym &amp;noise, TVectorD &amp;deltaState) const</td></tr>
<tr class="memdesc:a100bb8b3cd47c4f13fb3fc8e044a1980"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the jacobian and noise matrix of the last extrapolation. <br /></td></tr>
<tr class="separator:a100bb8b3cd47c4f13fb3fc8e044a1980"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab686cd76fe00a4b67cecd42d8c9183b9"><td class="memItemLeft" align="right" valign="top"><a id="ab686cd76fe00a4b67cecd42d8c9183b9"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgenfit_1_1RKTrackRep.html#ab686cd76fe00a4b67cecd42d8c9183b9">getBackwardJacobianAndNoise</a> (TMatrixD &amp;jacobian, TMatrixDSym &amp;noise, TVectorD &amp;deltaState) const</td></tr>
<tr class="memdesc:ab686cd76fe00a4b67cecd42d8c9183b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the jacobian and noise matrix of the last extrapolation if it would have been done in opposite direction. <br /></td></tr>
<tr class="separator:ab686cd76fe00a4b67cecd42d8c9183b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff5d9a16cfa0c3f02698467f2ef1e27e"><td class="memItemLeft" align="right" valign="top"><a id="aff5d9a16cfa0c3f02698467f2ef1e27e"></a>
std::vector&lt; <a class="el" href="structgenfit_1_1MatStep.html">genfit::MatStep</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgenfit_1_1RKTrackRep.html#aff5d9a16cfa0c3f02698467f2ef1e27e">getSteps</a> () const</td></tr>
<tr class="memdesc:aff5d9a16cfa0c3f02698467f2ef1e27e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get stepsizes and material properties of crossed materials of the last extrapolation. <br /></td></tr>
<tr class="separator:aff5d9a16cfa0c3f02698467f2ef1e27e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74fb80a21741cc6d9290b21addba6c75"><td class="memItemLeft" align="right" valign="top"><a id="a74fb80a21741cc6d9290b21addba6c75"></a>
virtual double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgenfit_1_1RKTrackRep.html#a74fb80a21741cc6d9290b21addba6c75">getRadiationLenght</a> () const</td></tr>
<tr class="memdesc:a74fb80a21741cc6d9290b21addba6c75"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the accumulated X/X0 (path / radiation length) of the material crossed in the last extrapolation. <br /></td></tr>
<tr class="separator:a74fb80a21741cc6d9290b21addba6c75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae71e36989f017cc990fdd47e87bc4447"><td class="memItemLeft" align="right" valign="top"><a id="ae71e36989f017cc990fdd47e87bc4447"></a>
virtual double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgenfit_1_1RKTrackRep.html#ae71e36989f017cc990fdd47e87bc4447">getTOF</a> () const</td></tr>
<tr class="memdesc:ae71e36989f017cc990fdd47e87bc4447"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the time of flight [ns] of the last extrapolation. <br /></td></tr>
<tr class="separator:ae71e36989f017cc990fdd47e87bc4447"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8cf9535c2cfef5f12915de536941986e"><td class="memItemLeft" align="right" valign="top"><a id="a8cf9535c2cfef5f12915de536941986e"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgenfit_1_1RKTrackRep.html#a8cf9535c2cfef5f12915de536941986e">setPosMom</a> (<a class="el" href="classgenfit_1_1StateOnPlane.html">StateOnPlane</a> &amp;state, const TVector3 &amp;pos, const TVector3 &amp;mom) const</td></tr>
<tr class="memdesc:a8cf9535c2cfef5f12915de536941986e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set position and momentum of state. <br /></td></tr>
<tr class="separator:a8cf9535c2cfef5f12915de536941986e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a747be9a6b854b5c47e2e7eaf806c185f"><td class="memItemLeft" align="right" valign="top"><a id="a747be9a6b854b5c47e2e7eaf806c185f"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgenfit_1_1RKTrackRep.html#a747be9a6b854b5c47e2e7eaf806c185f">setPosMom</a> (<a class="el" href="classgenfit_1_1StateOnPlane.html">StateOnPlane</a> &amp;state, const TVectorD &amp;state6) const</td></tr>
<tr class="memdesc:a747be9a6b854b5c47e2e7eaf806c185f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set position and momentum of state. <br /></td></tr>
<tr class="separator:a747be9a6b854b5c47e2e7eaf806c185f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99e37f2ab61f0473a26725979c94998d"><td class="memItemLeft" align="right" valign="top"><a id="a99e37f2ab61f0473a26725979c94998d"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgenfit_1_1RKTrackRep.html#a99e37f2ab61f0473a26725979c94998d">setPosMomErr</a> (<a class="el" href="classgenfit_1_1MeasuredStateOnPlane.html">MeasuredStateOnPlane</a> &amp;state, const TVector3 &amp;pos, const TVector3 &amp;mom, const TVector3 &amp;posErr, const TVector3 &amp;momErr) const</td></tr>
<tr class="memdesc:a99e37f2ab61f0473a26725979c94998d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set position and momentum and error of state. <br /></td></tr>
<tr class="separator:a99e37f2ab61f0473a26725979c94998d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b5455a69aae5687a9743c9f2f5d946c"><td class="memItemLeft" align="right" valign="top"><a id="a8b5455a69aae5687a9743c9f2f5d946c"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgenfit_1_1RKTrackRep.html#a8b5455a69aae5687a9743c9f2f5d946c">setPosMomCov</a> (<a class="el" href="classgenfit_1_1MeasuredStateOnPlane.html">MeasuredStateOnPlane</a> &amp;state, const TVector3 &amp;pos, const TVector3 &amp;mom, const TMatrixDSym &amp;cov6x6) const</td></tr>
<tr class="memdesc:a8b5455a69aae5687a9743c9f2f5d946c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set position, momentum and covariance of state. <br /></td></tr>
<tr class="separator:a8b5455a69aae5687a9743c9f2f5d946c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a248147a042b603431d22bd285ee14adc"><td class="memItemLeft" align="right" valign="top"><a id="a248147a042b603431d22bd285ee14adc"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgenfit_1_1RKTrackRep.html#a248147a042b603431d22bd285ee14adc">setPosMomCov</a> (<a class="el" href="classgenfit_1_1MeasuredStateOnPlane.html">MeasuredStateOnPlane</a> &amp;state, const TVectorD &amp;state6, const TMatrixDSym &amp;cov6x6) const</td></tr>
<tr class="memdesc:a248147a042b603431d22bd285ee14adc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set position, momentum and covariance of state. <br /></td></tr>
<tr class="separator:a248147a042b603431d22bd285ee14adc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9adae2d78ae5e04ca2a2039ce981bc8"><td class="memItemLeft" align="right" valign="top"><a id="ac9adae2d78ae5e04ca2a2039ce981bc8"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgenfit_1_1RKTrackRep.html#ac9adae2d78ae5e04ca2a2039ce981bc8">setChargeSign</a> (<a class="el" href="classgenfit_1_1StateOnPlane.html">StateOnPlane</a> &amp;state, double charge) const</td></tr>
<tr class="memdesc:ac9adae2d78ae5e04ca2a2039ce981bc8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the sign of the charge according to charge. <br /></td></tr>
<tr class="separator:ac9adae2d78ae5e04ca2a2039ce981bc8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1eb48cd7c3e1c5d954563cea4d37576d"><td class="memItemLeft" align="right" valign="top"><a id="a1eb48cd7c3e1c5d954563cea4d37576d"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgenfit_1_1RKTrackRep.html#a1eb48cd7c3e1c5d954563cea4d37576d">setQop</a> (<a class="el" href="classgenfit_1_1StateOnPlane.html">StateOnPlane</a> &amp;state, double qop) const</td></tr>
<tr class="memdesc:a1eb48cd7c3e1c5d954563cea4d37576d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set charge/momentum. <br /></td></tr>
<tr class="separator:a1eb48cd7c3e1c5d954563cea4d37576d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a324ba092d634f324285f445b4bba12b6"><td class="memItemLeft" align="right" valign="top"><a id="a324ba092d634f324285f445b4bba12b6"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>setSpu</b> (<a class="el" href="classgenfit_1_1StateOnPlane.html">StateOnPlane</a> &amp;state, double spu) const</td></tr>
<tr class="separator:a324ba092d634f324285f445b4bba12b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:affa6945eaba3b0f2b143d039967b834e"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgenfit_1_1RKTrackRep.html#affa6945eaba3b0f2b143d039967b834e">RKPropagate</a> (M1x7 &amp;state7, M7x7 *jacobian, <a class="el" href="namespacegenfit.html#a3e8167b2b78ea4a8f7d5f6485640a6cd">M1x3</a> &amp;SA, double S, bool varField=true, bool calcOnlyLastRowOfJ=false) const</td></tr>
<tr class="memdesc:affa6945eaba3b0f2b143d039967b834e"><td class="mdescLeft">&#160;</td><td class="mdescRight">The actual Runge Kutta propagation.  <a href="#affa6945eaba3b0f2b143d039967b834e">More...</a><br /></td></tr>
<tr class="separator:affa6945eaba3b0f2b143d039967b834e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48d03ccf2fe92bda3fc13ef7878e58a1"><td class="memItemLeft" align="right" valign="top"><a id="a48d03ccf2fe92bda3fc13ef7878e58a1"></a>
virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgenfit_1_1RKTrackRep.html#a48d03ccf2fe92bda3fc13ef7878e58a1">isSameType</a> (const <a class="el" href="classgenfit_1_1AbsTrackRep.html">AbsTrackRep</a> *other)</td></tr>
<tr class="memdesc:a48d03ccf2fe92bda3fc13ef7878e58a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">check if other is of same type (e.g. <a class="el" href="classgenfit_1_1RKTrackRep.html" title="AbsTrackRep with 5D track parameterization in plane coordinates: (q/p, u&#39;, v&#39;, u, v) ...">RKTrackRep</a>). <br /></td></tr>
<tr class="separator:a48d03ccf2fe92bda3fc13ef7878e58a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc17228d76c6656b308bbcf4e4ee8a7d"><td class="memItemLeft" align="right" valign="top"><a id="acc17228d76c6656b308bbcf4e4ee8a7d"></a>
virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgenfit_1_1RKTrackRep.html#acc17228d76c6656b308bbcf4e4ee8a7d">isSame</a> (const <a class="el" href="classgenfit_1_1AbsTrackRep.html">AbsTrackRep</a> *other)</td></tr>
<tr class="memdesc:acc17228d76c6656b308bbcf4e4ee8a7d"><td class="mdescLeft">&#160;</td><td class="mdescRight">check if other is of same type (e.g. <a class="el" href="classgenfit_1_1RKTrackRep.html" title="AbsTrackRep with 5D track parameterization in plane coordinates: (q/p, u&#39;, v&#39;, u, v) ...">RKTrackRep</a>) and has same pdg code. <br /></td></tr>
<tr class="separator:acc17228d76c6656b308bbcf4e4ee8a7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classgenfit_1_1AbsTrackRep"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classgenfit_1_1AbsTrackRep')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classgenfit_1_1AbsTrackRep.html">genfit::AbsTrackRep</a></td></tr>
<tr class="memitem:a7b04f7361b67d3684947852cc908e9d7 inherit pub_methods_classgenfit_1_1AbsTrackRep"><td class="memItemLeft" align="right" valign="top"><a id="a7b04f7361b67d3684947852cc908e9d7"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>AbsTrackRep</b> (int pdgCode, char propDir=0)</td></tr>
<tr class="separator:a7b04f7361b67d3684947852cc908e9d7 inherit pub_methods_classgenfit_1_1AbsTrackRep"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abccad41ccef10c491ed0bcacd2dcb022 inherit pub_methods_classgenfit_1_1AbsTrackRep"><td class="memItemLeft" align="right" valign="top">virtual double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgenfit_1_1AbsTrackRep.html#abccad41ccef10c491ed0bcacd2dcb022">extrapolateToLine</a> (<a class="el" href="classgenfit_1_1StateOnPlane.html">StateOnPlane</a> &amp;state, const TVector3 &amp;point1, const TVector3 &amp;point2, TVector3 &amp;poca, TVector3 &amp;dirInPoca, TVector3 &amp;poca_onwire, bool stopAtBoundary=false, bool calcJacobianNoise=false) const</td></tr>
<tr class="memdesc:abccad41ccef10c491ed0bcacd2dcb022 inherit pub_methods_classgenfit_1_1AbsTrackRep"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resembles the interface of GFAbsTrackRep in old versions of genfit.  <a href="classgenfit_1_1AbsTrackRep.html#abccad41ccef10c491ed0bcacd2dcb022">More...</a><br /></td></tr>
<tr class="separator:abccad41ccef10c491ed0bcacd2dcb022 inherit pub_methods_classgenfit_1_1AbsTrackRep"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22347e986819863a90edca9a843f2929 inherit pub_methods_classgenfit_1_1AbsTrackRep"><td class="memItemLeft" align="right" valign="top"><a id="a22347e986819863a90edca9a843f2929"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgenfit_1_1AbsTrackRep.html#a22347e986819863a90edca9a843f2929">extrapolateToMeasurement</a> (<a class="el" href="classgenfit_1_1StateOnPlane.html">StateOnPlane</a> &amp;state, const <a class="el" href="classgenfit_1_1AbsMeasurement.html">AbsMeasurement</a> *measurement, bool stopAtBoundary=false, bool calcJacobianNoise=false) const</td></tr>
<tr class="memdesc:a22347e986819863a90edca9a843f2929 inherit pub_methods_classgenfit_1_1AbsTrackRep"><td class="mdescLeft">&#160;</td><td class="mdescRight">extrapolate to an <a class="el" href="classgenfit_1_1AbsMeasurement.html" title="Contains the measurement and covariance in raw detector coordinates. ">AbsMeasurement</a> <br /></td></tr>
<tr class="separator:a22347e986819863a90edca9a843f2929 inherit pub_methods_classgenfit_1_1AbsTrackRep"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3338706c6ecb501c79b874f0a69bb6c5 inherit pub_methods_classgenfit_1_1AbsTrackRep"><td class="memItemLeft" align="right" valign="top"><a id="a3338706c6ecb501c79b874f0a69bb6c5"></a>
TVector3&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgenfit_1_1AbsTrackRep.html#a3338706c6ecb501c79b874f0a69bb6c5">getDir</a> (const <a class="el" href="classgenfit_1_1StateOnPlane.html">StateOnPlane</a> &amp;state) const</td></tr>
<tr class="memdesc:a3338706c6ecb501c79b874f0a69bb6c5 inherit pub_methods_classgenfit_1_1AbsTrackRep"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the direction vector of a state. <br /></td></tr>
<tr class="separator:a3338706c6ecb501c79b874f0a69bb6c5 inherit pub_methods_classgenfit_1_1AbsTrackRep"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35be75979af239d64a580034c51ae39d inherit pub_methods_classgenfit_1_1AbsTrackRep"><td class="memItemLeft" align="right" valign="top"><a id="a35be75979af239d64a580034c51ae39d"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgenfit_1_1AbsTrackRep.html#a35be75979af239d64a580034c51ae39d">getPosDir</a> (const <a class="el" href="classgenfit_1_1StateOnPlane.html">StateOnPlane</a> &amp;state, TVector3 &amp;pos, TVector3 &amp;dir) const</td></tr>
<tr class="memdesc:a35be75979af239d64a580034c51ae39d inherit pub_methods_classgenfit_1_1AbsTrackRep"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get cartesian position and direction vector of a state. <br /></td></tr>
<tr class="separator:a35be75979af239d64a580034c51ae39d inherit pub_methods_classgenfit_1_1AbsTrackRep"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab46a119bcae7e465ad1ef10f4740952e inherit pub_methods_classgenfit_1_1AbsTrackRep"><td class="memItemLeft" align="right" valign="top"><a id="ab46a119bcae7e465ad1ef10f4740952e"></a>
virtual TVectorD&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgenfit_1_1AbsTrackRep.html#ab46a119bcae7e465ad1ef10f4740952e">get6DState</a> (const <a class="el" href="classgenfit_1_1StateOnPlane.html">StateOnPlane</a> &amp;state) const</td></tr>
<tr class="memdesc:ab46a119bcae7e465ad1ef10f4740952e inherit pub_methods_classgenfit_1_1AbsTrackRep"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the 6D state vector (x, y, z, p_x, p_y, p_z). <br /></td></tr>
<tr class="separator:ab46a119bcae7e465ad1ef10f4740952e inherit pub_methods_classgenfit_1_1AbsTrackRep"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abfb2ebef9afa7e7ca65a3af7381ba156 inherit pub_methods_classgenfit_1_1AbsTrackRep"><td class="memItemLeft" align="right" valign="top"><a id="abfb2ebef9afa7e7ca65a3af7381ba156"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgenfit_1_1AbsTrackRep.html#abfb2ebef9afa7e7ca65a3af7381ba156">get6DStateCov</a> (const <a class="el" href="classgenfit_1_1MeasuredStateOnPlane.html">MeasuredStateOnPlane</a> &amp;state, TVectorD &amp;stateVec, TMatrixDSym &amp;cov) const</td></tr>
<tr class="memdesc:abfb2ebef9afa7e7ca65a3af7381ba156 inherit pub_methods_classgenfit_1_1AbsTrackRep"><td class="mdescLeft">&#160;</td><td class="mdescRight">Translates <a class="el" href="classgenfit_1_1MeasuredStateOnPlane.html" title="#StateOnPlane with additional covariance matrix. ">MeasuredStateOnPlane</a> into 6D state vector (x, y, z, p_x, p_y, p_z) and 6x6 covariance. <br /></td></tr>
<tr class="separator:abfb2ebef9afa7e7ca65a3af7381ba156 inherit pub_methods_classgenfit_1_1AbsTrackRep"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a718e040ec8f22ef738af7c9005355443 inherit pub_methods_classgenfit_1_1AbsTrackRep"><td class="memItemLeft" align="right" valign="top"><a id="a718e040ec8f22ef738af7c9005355443"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgenfit_1_1AbsTrackRep.html#a718e040ec8f22ef738af7c9005355443">getPDG</a> () const</td></tr>
<tr class="memdesc:a718e040ec8f22ef738af7c9005355443 inherit pub_methods_classgenfit_1_1AbsTrackRep"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the pdg code. <br /></td></tr>
<tr class="separator:a718e040ec8f22ef738af7c9005355443 inherit pub_methods_classgenfit_1_1AbsTrackRep"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf70894cebf437f09c284953d7e60734 inherit pub_methods_classgenfit_1_1AbsTrackRep"><td class="memItemLeft" align="right" valign="top"><a id="aaf70894cebf437f09c284953d7e60734"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgenfit_1_1AbsTrackRep.html#aaf70894cebf437f09c284953d7e60734">getPDGCharge</a> () const</td></tr>
<tr class="memdesc:aaf70894cebf437f09c284953d7e60734 inherit pub_methods_classgenfit_1_1AbsTrackRep"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the charge of the particle of the pdg code. <br /></td></tr>
<tr class="separator:aaf70894cebf437f09c284953d7e60734 inherit pub_methods_classgenfit_1_1AbsTrackRep"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f0073f2446a780e27886ab512e7787f inherit pub_methods_classgenfit_1_1AbsTrackRep"><td class="memItemLeft" align="right" valign="top"><a id="a7f0073f2446a780e27886ab512e7787f"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgenfit_1_1AbsTrackRep.html#a7f0073f2446a780e27886ab512e7787f">getMass</a> (const <a class="el" href="classgenfit_1_1StateOnPlane.html">StateOnPlane</a> &amp;state) const</td></tr>
<tr class="memdesc:a7f0073f2446a780e27886ab512e7787f inherit pub_methods_classgenfit_1_1AbsTrackRep"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get tha particle mass in GeV/c^2. <br /></td></tr>
<tr class="separator:a7f0073f2446a780e27886ab512e7787f inherit pub_methods_classgenfit_1_1AbsTrackRep"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a620617c8eecd6cf2aaa3ae40231a8979 inherit pub_methods_classgenfit_1_1AbsTrackRep"><td class="memItemLeft" align="right" valign="top"><a id="a620617c8eecd6cf2aaa3ae40231a8979"></a>
char&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgenfit_1_1AbsTrackRep.html#a620617c8eecd6cf2aaa3ae40231a8979">getPropDir</a> () const</td></tr>
<tr class="memdesc:a620617c8eecd6cf2aaa3ae40231a8979 inherit pub_methods_classgenfit_1_1AbsTrackRep"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get propagation direction. (-1, 0, 1) -&gt; (backward, auto, forward). <br /></td></tr>
<tr class="separator:a620617c8eecd6cf2aaa3ae40231a8979 inherit pub_methods_classgenfit_1_1AbsTrackRep"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50abfd7a67b5b1347780a216cbee5423 inherit pub_methods_classgenfit_1_1AbsTrackRep"><td class="memItemLeft" align="right" valign="top"><a id="a50abfd7a67b5b1347780a216cbee5423"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgenfit_1_1AbsTrackRep.html#a50abfd7a67b5b1347780a216cbee5423">calcJacobianNumerically</a> (const <a class="el" href="classgenfit_1_1StateOnPlane.html">genfit::StateOnPlane</a> &amp;origState, const <a class="el" href="namespacegenfit.html#a53bfc6c64a1fe1c3abea814a500dd60d">genfit::SharedPlanePtr</a> destPlane, TMatrixD &amp;jacobian) const</td></tr>
<tr class="memdesc:a50abfd7a67b5b1347780a216cbee5423 inherit pub_methods_classgenfit_1_1AbsTrackRep"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate Jacobian of transportation numerically. Slow but accurate. Can be used to validate (semi)analytic calculations. <br /></td></tr>
<tr class="separator:a50abfd7a67b5b1347780a216cbee5423 inherit pub_methods_classgenfit_1_1AbsTrackRep"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a754b00fa09fe85760439462bc22bca84 inherit pub_methods_classgenfit_1_1AbsTrackRep"><td class="memItemLeft" align="right" valign="top"><a id="a754b00fa09fe85760439462bc22bca84"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgenfit_1_1AbsTrackRep.html#a754b00fa09fe85760439462bc22bca84">switchPDGSign</a> ()</td></tr>
<tr class="memdesc:a754b00fa09fe85760439462bc22bca84 inherit pub_methods_classgenfit_1_1AbsTrackRep"><td class="mdescLeft">&#160;</td><td class="mdescRight">try to multiply pdg code with -1. (Switch from particle to anti-particle and vice versa). <br /></td></tr>
<tr class="separator:a754b00fa09fe85760439462bc22bca84 inherit pub_methods_classgenfit_1_1AbsTrackRep"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ab24657168d34266cf73301cfd66794 inherit pub_methods_classgenfit_1_1AbsTrackRep"><td class="memItemLeft" align="right" valign="top"><a id="a6ab24657168d34266cf73301cfd66794"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgenfit_1_1AbsTrackRep.html#a6ab24657168d34266cf73301cfd66794">setPropDir</a> (int dir)</td></tr>
<tr class="memdesc:a6ab24657168d34266cf73301cfd66794 inherit pub_methods_classgenfit_1_1AbsTrackRep"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set propagation direction. (-1, 0, 1) -&gt; (backward, auto, forward). <br /></td></tr>
<tr class="separator:a6ab24657168d34266cf73301cfd66794 inherit pub_methods_classgenfit_1_1AbsTrackRep"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd12dbf3680a5cfe682121b78480e8a0 inherit pub_methods_classgenfit_1_1AbsTrackRep"><td class="memItemLeft" align="right" valign="top"><a id="abd12dbf3680a5cfe682121b78480e8a0"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgenfit_1_1AbsTrackRep.html#abd12dbf3680a5cfe682121b78480e8a0">switchPropDir</a> ()</td></tr>
<tr class="memdesc:abd12dbf3680a5cfe682121b78480e8a0 inherit pub_methods_classgenfit_1_1AbsTrackRep"><td class="mdescLeft">&#160;</td><td class="mdescRight">Switch propagation direction. Has no effect if propDir_ is set to 0. <br /></td></tr>
<tr class="separator:abd12dbf3680a5cfe682121b78480e8a0 inherit pub_methods_classgenfit_1_1AbsTrackRep"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33124135a41a0b240742e5490220e40c inherit pub_methods_classgenfit_1_1AbsTrackRep"><td class="memItemLeft" align="right" valign="top"><a id="a33124135a41a0b240742e5490220e40c"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>setDebugLvl</b> (unsigned int lvl=1)</td></tr>
<tr class="separator:a33124135a41a0b240742e5490220e40c inherit pub_methods_classgenfit_1_1AbsTrackRep"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa402977b82ac150f66e831e60cd48b86 inherit pub_methods_classgenfit_1_1AbsTrackRep"><td class="memItemLeft" align="right" valign="top"><a id="aa402977b82ac150f66e831e60cd48b86"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>Print</b> (const Option_t *=&quot;&quot;) const</td></tr>
<tr class="separator:aa402977b82ac150f66e831e60cd48b86 inherit pub_methods_classgenfit_1_1AbsTrackRep"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="inherited"></a>
Additional Inherited Members</h2></td></tr>
<tr class="inherit_header pro_methods_classgenfit_1_1AbsTrackRep"><td colspan="2" onclick="javascript:toggleInherit('pro_methods_classgenfit_1_1AbsTrackRep')"><img src="closed.png" alt="-"/>&#160;Protected Member Functions inherited from <a class="el" href="classgenfit_1_1AbsTrackRep.html">genfit::AbsTrackRep</a></td></tr>
<tr class="memitem:a67e8c7fe5ba51f1a563676b51a192c94 inherit pro_methods_classgenfit_1_1AbsTrackRep"><td class="memItemLeft" align="right" valign="top"><a id="a67e8c7fe5ba51f1a563676b51a192c94"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgenfit_1_1AbsTrackRep.html#a67e8c7fe5ba51f1a563676b51a192c94">AbsTrackRep</a> (const <a class="el" href="classgenfit_1_1AbsTrackRep.html">AbsTrackRep</a> &amp;)</td></tr>
<tr class="memdesc:a67e8c7fe5ba51f1a563676b51a192c94 inherit pro_methods_classgenfit_1_1AbsTrackRep"><td class="mdescLeft">&#160;</td><td class="mdescRight">protect from calling copy c'tor from outside the class. Use <a class="el" href="classgenfit_1_1AbsTrackRep.html#a167993908a742633c6216cf811ea3ea2" title="Clone the trackRep. ">clone()</a> if you want a copy! <br /></td></tr>
<tr class="separator:a67e8c7fe5ba51f1a563676b51a192c94 inherit pro_methods_classgenfit_1_1AbsTrackRep"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a061a0373454c317844762ce9d16184c4 inherit pro_methods_classgenfit_1_1AbsTrackRep"><td class="memItemLeft" align="right" valign="top"><a id="a061a0373454c317844762ce9d16184c4"></a>
<a class="el" href="classgenfit_1_1AbsTrackRep.html">AbsTrackRep</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgenfit_1_1AbsTrackRep.html#a061a0373454c317844762ce9d16184c4">operator=</a> (const <a class="el" href="classgenfit_1_1AbsTrackRep.html">AbsTrackRep</a> &amp;)</td></tr>
<tr class="memdesc:a061a0373454c317844762ce9d16184c4 inherit pro_methods_classgenfit_1_1AbsTrackRep"><td class="mdescLeft">&#160;</td><td class="mdescRight">protect from calling assignment operator from outside the class. Use <a class="el" href="classgenfit_1_1AbsTrackRep.html#a167993908a742633c6216cf811ea3ea2" title="Clone the trackRep. ">clone()</a> instead! <br /></td></tr>
<tr class="separator:a061a0373454c317844762ce9d16184c4 inherit pro_methods_classgenfit_1_1AbsTrackRep"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_attribs_classgenfit_1_1AbsTrackRep"><td colspan="2" onclick="javascript:toggleInherit('pro_attribs_classgenfit_1_1AbsTrackRep')"><img src="closed.png" alt="-"/>&#160;Protected Attributes inherited from <a class="el" href="classgenfit_1_1AbsTrackRep.html">genfit::AbsTrackRep</a></td></tr>
<tr class="memitem:a29cc69d36b01cab1d0c6fc8a9529fac4 inherit pro_attribs_classgenfit_1_1AbsTrackRep"><td class="memItemLeft" align="right" valign="top"><a id="a29cc69d36b01cab1d0c6fc8a9529fac4"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgenfit_1_1AbsTrackRep.html#a29cc69d36b01cab1d0c6fc8a9529fac4">pdgCode_</a></td></tr>
<tr class="memdesc:a29cc69d36b01cab1d0c6fc8a9529fac4 inherit pro_attribs_classgenfit_1_1AbsTrackRep"><td class="mdescLeft">&#160;</td><td class="mdescRight">Particle code. <br /></td></tr>
<tr class="separator:a29cc69d36b01cab1d0c6fc8a9529fac4 inherit pro_attribs_classgenfit_1_1AbsTrackRep"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8b046499b9651e30c0d4e06243c58b4 inherit pro_attribs_classgenfit_1_1AbsTrackRep"><td class="memItemLeft" align="right" valign="top"><a id="af8b046499b9651e30c0d4e06243c58b4"></a>
char&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgenfit_1_1AbsTrackRep.html#af8b046499b9651e30c0d4e06243c58b4">propDir_</a></td></tr>
<tr class="memdesc:af8b046499b9651e30c0d4e06243c58b4 inherit pro_attribs_classgenfit_1_1AbsTrackRep"><td class="mdescLeft">&#160;</td><td class="mdescRight">propagation direction (-1, 0, 1) -&gt; (backward, auto, forward) <br /></td></tr>
<tr class="separator:af8b046499b9651e30c0d4e06243c58b4 inherit pro_attribs_classgenfit_1_1AbsTrackRep"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af69df07f28005ab0da75a81b59b0af7f inherit pro_attribs_classgenfit_1_1AbsTrackRep"><td class="memItemLeft" align="right" valign="top"><a id="af69df07f28005ab0da75a81b59b0af7f"></a>
unsigned int&#160;</td><td class="memItemRight" valign="bottom"><b>debugLvl_</b></td></tr>
<tr class="separator:af69df07f28005ab0da75a81b59b0af7f inherit pro_attribs_classgenfit_1_1AbsTrackRep"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p><a class="el" href="classgenfit_1_1AbsTrackRep.html" title="Abstract base class for a track representation. ">AbsTrackRep</a> with 5D track parameterization in plane coordinates: (q/p, u', v', u, v) </p>
<p>q/p is charge over momentum. u' and v' are direction tangents. u and v are positions on a <a class="el" href="classgenfit_1_1DetPlane.html" title="Detector plane. ">DetPlane</a>. </p>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a id="a6e8225094b2cba938c3dcef7261ccfb0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6e8225094b2cba938c3dcef7261ccfb0">&sect;&nbsp;</a></span>extrapolateBy() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double genfit::RKTrackRep::extrapolateBy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classgenfit_1_1StateOnPlane.html">StateOnPlane</a> &amp;&#160;</td>
          <td class="paramname"><em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>step</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>stopAtBoundary</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>calcJacobianNoise</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Extrapolates the state by step (cm) and returns the extrapolation length and, via reference, the extrapolated state. </p>
<p>If stopAtBoundary is true, the extrapolation stops as soon as a material boundary is encountered.</p>
<p>If state has a covariance, jacobian and noise matrices will be calculated and the covariance will be propagated. If state has no covariance, jacobian and noise will only be calculated if calcJacobianNoise == true. </p>

<p>Implements <a class="el" href="classgenfit_1_1AbsTrackRep.html#aff2dc02475fbef55f521373a8659d020">genfit::AbsTrackRep</a>.</p>

</div>
</div>
<a id="a4f4323fd5ad69bce79d82d0af287417e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4f4323fd5ad69bce79d82d0af287417e">&sect;&nbsp;</a></span>extrapolateBy() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual double genfit::RKTrackRep::extrapolateBy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classgenfit_1_1StateOnPlane.html">StateOnPlane</a> &amp;&#160;</td>
          <td class="paramname"><em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>step</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>stopAtBoundary</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>calcJacobianNoise</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Extrapolates the state by step (cm) and returns the extrapolation length and, via reference, the extrapolated state. </p>
<p>If stopAtBoundary is true, the extrapolation stops as soon as a material boundary is encountered.</p>
<p>If state has a covariance, jacobian and noise matrices will be calculated and the covariance will be propagated. If state has no covariance, jacobian and noise will only be calculated if calcJacobianNoise == true. </p>

<p>Implements <a class="el" href="classgenfit_1_1AbsTrackRep.html#aff2dc02475fbef55f521373a8659d020">genfit::AbsTrackRep</a>.</p>

</div>
</div>
<a id="a7cfb69ae23f997f00073c2178771e233"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7cfb69ae23f997f00073c2178771e233">&sect;&nbsp;</a></span>extrapolateToCylinder() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double genfit::RKTrackRep::extrapolateToCylinder </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classgenfit_1_1StateOnPlane.html">StateOnPlane</a> &amp;&#160;</td>
          <td class="paramname"><em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>radius</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TVector3 &amp;&#160;</td>
          <td class="paramname"><em>linePoint</em> = <code>TVector3(0.,&#160;0.,&#160;0.)</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TVector3 &amp;&#160;</td>
          <td class="paramname"><em>lineDirection</em> = <code>TVector3(0.,&#160;0.,&#160;1.)</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>stopAtBoundary</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>calcJacobianNoise</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Extrapolates the state to the cylinder surface, and returns the extrapolation length and, via reference, the extrapolated state. </p>
<p>If stopAtBoundary is true, the extrapolation stops as soon as a material boundary is encountered.</p>
<p>If state has a covariance, jacobian and noise matrices will be calculated and the covariance will be propagated. If state has no covariance, jacobian and noise will only be calculated if calcJacobianNoise == true. </p>

<p>Implements <a class="el" href="classgenfit_1_1AbsTrackRep.html#a3159647541c1414d7bfd2c97eec716ac">genfit::AbsTrackRep</a>.</p>

</div>
</div>
<a id="aa91d6caaf330881eead525c66dff955f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa91d6caaf330881eead525c66dff955f">&sect;&nbsp;</a></span>extrapolateToCylinder() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual double genfit::RKTrackRep::extrapolateToCylinder </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classgenfit_1_1StateOnPlane.html">StateOnPlane</a> &amp;&#160;</td>
          <td class="paramname"><em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>radius</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TVector3 &amp;&#160;</td>
          <td class="paramname"><em>linePoint</em> = <code>TVector3(0.,&#160;0.,&#160;0.)</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TVector3 &amp;&#160;</td>
          <td class="paramname"><em>lineDirection</em> = <code>TVector3(0.,&#160;0.,&#160;1.)</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>stopAtBoundary</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>calcJacobianNoise</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Extrapolates the state to the cylinder surface, and returns the extrapolation length and, via reference, the extrapolated state. </p>
<p>If stopAtBoundary is true, the extrapolation stops as soon as a material boundary is encountered.</p>
<p>If state has a covariance, jacobian and noise matrices will be calculated and the covariance will be propagated. If state has no covariance, jacobian and noise will only be calculated if calcJacobianNoise == true. </p>

<p>Implements <a class="el" href="classgenfit_1_1AbsTrackRep.html#a3159647541c1414d7bfd2c97eec716ac">genfit::AbsTrackRep</a>.</p>

</div>
</div>
<a id="af556c558f049d00b43b079bd363564d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af556c558f049d00b43b079bd363564d9">&sect;&nbsp;</a></span>extrapolateToLine() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double genfit::RKTrackRep::extrapolateToLine </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classgenfit_1_1StateOnPlane.html">StateOnPlane</a> &amp;&#160;</td>
          <td class="paramname"><em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TVector3 &amp;&#160;</td>
          <td class="paramname"><em>linePoint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TVector3 &amp;&#160;</td>
          <td class="paramname"><em>lineDirection</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>stopAtBoundary</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>calcJacobianNoise</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Extrapolates the state to the POCA to a line, and returns the extrapolation length and, via reference, the extrapolated state. </p>
<p>If stopAtBoundary is true, the extrapolation stops as soon as a material boundary is encountered.</p>
<p>If state has a covariance, jacobian and noise matrices will be calculated and the covariance will be propagated. If state has no covariance, jacobian and noise will only be calculated if calcJacobianNoise == true. </p>

<p>Implements <a class="el" href="classgenfit_1_1AbsTrackRep.html#a4442c7a510c9bc05a51130350f2268a1">genfit::AbsTrackRep</a>.</p>

</div>
</div>
<a id="afeebe12bb8b5385b4ed46258271e7f13"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afeebe12bb8b5385b4ed46258271e7f13">&sect;&nbsp;</a></span>extrapolateToLine() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual double genfit::RKTrackRep::extrapolateToLine </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classgenfit_1_1StateOnPlane.html">StateOnPlane</a> &amp;&#160;</td>
          <td class="paramname"><em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TVector3 &amp;&#160;</td>
          <td class="paramname"><em>linePoint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TVector3 &amp;&#160;</td>
          <td class="paramname"><em>lineDirection</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>stopAtBoundary</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>calcJacobianNoise</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Extrapolates the state to the POCA to a line, and returns the extrapolation length and, via reference, the extrapolated state. </p>
<p>If stopAtBoundary is true, the extrapolation stops as soon as a material boundary is encountered.</p>
<p>If state has a covariance, jacobian and noise matrices will be calculated and the covariance will be propagated. If state has no covariance, jacobian and noise will only be calculated if calcJacobianNoise == true. </p>

<p>Implements <a class="el" href="classgenfit_1_1AbsTrackRep.html#a4442c7a510c9bc05a51130350f2268a1">genfit::AbsTrackRep</a>.</p>

</div>
</div>
<a id="a43755174182fc4f0e42cae45b690baae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a43755174182fc4f0e42cae45b690baae">&sect;&nbsp;</a></span>extrapolateToPlane() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual double genfit::RKTrackRep::extrapolateToPlane </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classgenfit_1_1StateOnPlane.html">StateOnPlane</a> &amp;&#160;</td>
          <td class="paramname"><em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacegenfit.html#a53bfc6c64a1fe1c3abea814a500dd60d">SharedPlanePtr</a> &amp;&#160;</td>
          <td class="paramname"><em>plane</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>stopAtBoundary</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>calcJacobianNoise</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Extrapolates the state to plane, and returns the extrapolation length and, via reference, the extrapolated state. </p>
<p>If stopAtBoundary is true, the extrapolation stops as soon as a material boundary is encountered.</p>
<p>If state has a covariance, jacobian and noise matrices will be calculated and the covariance will be propagated. If state has no covariance, jacobian and noise will only be calculated if calcJacobianNoise == true. </p>

<p>Implements <a class="el" href="classgenfit_1_1AbsTrackRep.html#a2f8c69950056c0c679d66bfb2eae2431">genfit::AbsTrackRep</a>.</p>

</div>
</div>
<a id="ade2e4cf73880a2df757e9dd372bf7b00"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ade2e4cf73880a2df757e9dd372bf7b00">&sect;&nbsp;</a></span>extrapolateToPlane() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double genfit::RKTrackRep::extrapolateToPlane </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classgenfit_1_1StateOnPlane.html">StateOnPlane</a> &amp;&#160;</td>
          <td class="paramname"><em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacegenfit.html#a53bfc6c64a1fe1c3abea814a500dd60d">SharedPlanePtr</a> &amp;&#160;</td>
          <td class="paramname"><em>plane</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>stopAtBoundary</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>calcJacobianNoise</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Extrapolates the state to plane, and returns the extrapolation length and, via reference, the extrapolated state. </p>
<p>If stopAtBoundary is true, the extrapolation stops as soon as a material boundary is encountered.</p>
<p>If state has a covariance, jacobian and noise matrices will be calculated and the covariance will be propagated. If state has no covariance, jacobian and noise will only be calculated if calcJacobianNoise == true. </p>

<p>Implements <a class="el" href="classgenfit_1_1AbsTrackRep.html#a2f8c69950056c0c679d66bfb2eae2431">genfit::AbsTrackRep</a>.</p>

</div>
</div>
<a id="afb99d5a9c3b53087dfbd30cb1d393eaa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afb99d5a9c3b53087dfbd30cb1d393eaa">&sect;&nbsp;</a></span>extrapolateToPoint() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual double genfit::RKTrackRep::extrapolateToPoint </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classgenfit_1_1StateOnPlane.html">StateOnPlane</a> &amp;&#160;</td>
          <td class="paramname"><em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TVector3 &amp;&#160;</td>
          <td class="paramname"><em>point</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>stopAtBoundary</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>calcJacobianNoise</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Extrapolates the state to the POCA to a point, and returns the extrapolation length and, via reference, the extrapolated state. </p>
<p>If stopAtBoundary is true, the extrapolation stops as soon as a material boundary is encountered.</p>
<p>If state has a covariance, jacobian and noise matrices will be calculated and the covariance will be propagated. If state has no covariance, jacobian and noise will only be calculated if calcJacobianNoise == true. </p>

<p>Implements <a class="el" href="classgenfit_1_1AbsTrackRep.html#adf11f826cc9b4d61fed7d7141e833e94">genfit::AbsTrackRep</a>.</p>

</div>
</div>
<a id="afb99d5a9c3b53087dfbd30cb1d393eaa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afb99d5a9c3b53087dfbd30cb1d393eaa">&sect;&nbsp;</a></span>extrapolateToPoint() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual double genfit::RKTrackRep::extrapolateToPoint </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classgenfit_1_1StateOnPlane.html">StateOnPlane</a> &amp;&#160;</td>
          <td class="paramname"><em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TVector3 &amp;&#160;</td>
          <td class="paramname"><em>point</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>stopAtBoundary</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>calcJacobianNoise</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Extrapolates the state to the POCA to a point, and returns the extrapolation length and, via reference, the extrapolated state. </p>
<p>If stopAtBoundary is true, the extrapolation stops as soon as a material boundary is encountered.</p>
<p>If state has a covariance, jacobian and noise matrices will be calculated and the covariance will be propagated. If state has no covariance, jacobian and noise will only be calculated if calcJacobianNoise == true. </p>

<p>Implements <a class="el" href="classgenfit_1_1AbsTrackRep.html#adf11f826cc9b4d61fed7d7141e833e94">genfit::AbsTrackRep</a>.</p>

</div>
</div>
<a id="add04b97a56a22832fed2a96bfa45a597"></a>
<h2 class="memtitle"><span class="permalink"><a href="#add04b97a56a22832fed2a96bfa45a597">&sect;&nbsp;</a></span>extrapolateToPoint() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual double genfit::RKTrackRep::extrapolateToPoint </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classgenfit_1_1StateOnPlane.html">StateOnPlane</a> &amp;&#160;</td>
          <td class="paramname"><em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TVector3 &amp;&#160;</td>
          <td class="paramname"><em>point</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TMatrixDSym &amp;&#160;</td>
          <td class="paramname"><em>G</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>stopAtBoundary</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>calcJacobianNoise</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Extrapolates the state to the POCA to a point in the metric of G, and returns the extrapolation length and, via reference, the extrapolated state. </p>
<p>If stopAtBoundary is true, the extrapolation stops as soon as a material boundary is encountered.</p>
<p>If state has a covariance, jacobian and noise matrices will be calculated and the covariance will be propagated. If state has no covariance, jacobian and noise will only be calculated if calcJacobianNoise == true. </p>

<p>Implements <a class="el" href="classgenfit_1_1AbsTrackRep.html#a8b5b1181ba3ee5b1310ca8d09359797d">genfit::AbsTrackRep</a>.</p>

</div>
</div>
<a id="add04b97a56a22832fed2a96bfa45a597"></a>
<h2 class="memtitle"><span class="permalink"><a href="#add04b97a56a22832fed2a96bfa45a597">&sect;&nbsp;</a></span>extrapolateToPoint() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual double genfit::RKTrackRep::extrapolateToPoint </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classgenfit_1_1StateOnPlane.html">StateOnPlane</a> &amp;&#160;</td>
          <td class="paramname"><em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TVector3 &amp;&#160;</td>
          <td class="paramname"><em>point</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TMatrixDSym &amp;&#160;</td>
          <td class="paramname"><em>G</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>stopAtBoundary</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>calcJacobianNoise</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Extrapolates the state to the POCA to a point in the metric of G, and returns the extrapolation length and, via reference, the extrapolated state. </p>
<p>If stopAtBoundary is true, the extrapolation stops as soon as a material boundary is encountered.</p>
<p>If state has a covariance, jacobian and noise matrices will be calculated and the covariance will be propagated. If state has no covariance, jacobian and noise will only be calculated if calcJacobianNoise == true. </p>

<p>Implements <a class="el" href="classgenfit_1_1AbsTrackRep.html#a8b5b1181ba3ee5b1310ca8d09359797d">genfit::AbsTrackRep</a>.</p>

</div>
</div>
<a id="a593518bed9f4385feab1623a66d734a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a593518bed9f4385feab1623a66d734a5">&sect;&nbsp;</a></span>extrapolateToSphere() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double genfit::RKTrackRep::extrapolateToSphere </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classgenfit_1_1StateOnPlane.html">StateOnPlane</a> &amp;&#160;</td>
          <td class="paramname"><em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>radius</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TVector3 &amp;&#160;</td>
          <td class="paramname"><em>point</em> = <code>TVector3(0.,&#160;0.,&#160;0.)</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>stopAtBoundary</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>calcJacobianNoise</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Extrapolates the state to the sphere surface, and returns the extrapolation length and, via reference, the extrapolated state. </p>
<p>If stopAtBoundary is true, the extrapolation stops as soon as a material boundary is encountered.</p>
<p>If state has a covariance, jacobian and noise matrices will be calculated and the covariance will be propagated. If state has no covariance, jacobian and noise will only be calculated if calcJacobianNoise == true. </p>

<p>Implements <a class="el" href="classgenfit_1_1AbsTrackRep.html#a7e6519f084e4ac5c58b3f3f8836cfbf0">genfit::AbsTrackRep</a>.</p>

</div>
</div>
<a id="a72111e10145836e1357cf6fa1aa59b63"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a72111e10145836e1357cf6fa1aa59b63">&sect;&nbsp;</a></span>extrapolateToSphere() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual double genfit::RKTrackRep::extrapolateToSphere </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classgenfit_1_1StateOnPlane.html">StateOnPlane</a> &amp;&#160;</td>
          <td class="paramname"><em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>radius</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TVector3 &amp;&#160;</td>
          <td class="paramname"><em>point</em> = <code>TVector3(0.,&#160;0.,&#160;0.)</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>stopAtBoundary</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>calcJacobianNoise</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Extrapolates the state to the sphere surface, and returns the extrapolation length and, via reference, the extrapolated state. </p>
<p>If stopAtBoundary is true, the extrapolation stops as soon as a material boundary is encountered.</p>
<p>If state has a covariance, jacobian and noise matrices will be calculated and the covariance will be propagated. If state has no covariance, jacobian and noise will only be calculated if calcJacobianNoise == true. </p>

<p>Implements <a class="el" href="classgenfit_1_1AbsTrackRep.html#a7e6519f084e4ac5c58b3f3f8836cfbf0">genfit::AbsTrackRep</a>.</p>

</div>
</div>
<a id="affa6945eaba3b0f2b143d039967b834e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#affa6945eaba3b0f2b143d039967b834e">&sect;&nbsp;</a></span>RKPropagate() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double genfit::RKTrackRep::RKPropagate </td>
          <td>(</td>
          <td class="paramtype">M1x7 &amp;&#160;</td>
          <td class="paramname"><em>state7</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">M7x7 *&#160;</td>
          <td class="paramname"><em>jacobian</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacegenfit.html#a3e8167b2b78ea4a8f7d5f6485640a6cd">M1x3</a> &amp;&#160;</td>
          <td class="paramname"><em>SA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>S</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>varField</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>calcOnlyLastRowOfJ</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The actual Runge Kutta propagation. </p>
<p>propagate state7 with step S. Fills SA (Start directions derivatives dA/S). If jacobian is NULL, only the state is propagated, otherwise also the 7x7 jacobian is calculated. If varField is false, the magnetic field will only be evaluated at the starting position. The return value is an estimation on how good the extrapolation is, and it is usually fine if it is &gt; 1. It gives a suggestion how you must scale S so that the quality will be sufficient. </p>

</div>
</div>
<a id="affa6945eaba3b0f2b143d039967b834e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#affa6945eaba3b0f2b143d039967b834e">&sect;&nbsp;</a></span>RKPropagate() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double genfit::RKTrackRep::RKPropagate </td>
          <td>(</td>
          <td class="paramtype">M1x7 &amp;&#160;</td>
          <td class="paramname"><em>state7</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">M7x7 *&#160;</td>
          <td class="paramname"><em>jacobian</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacegenfit.html#a3e8167b2b78ea4a8f7d5f6485640a6cd">M1x3</a> &amp;&#160;</td>
          <td class="paramname"><em>SA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>S</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>varField</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>calcOnlyLastRowOfJ</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The actual Runge Kutta propagation. </p>
<p>propagate state7 with step S. Fills SA (Start directions derivatives dA/S). If jacobian is NULL, only the state is propagated, otherwise also the 7x7 jacobian is calculated. If varField is false, the magnetic field will only be evaluated at the starting position. The return value is an estimation on how good the extrapolation is, and it is usually fine if it is &gt; 1. It gives a suggestion how you must scale S so that the quality will be sufficient. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>genfit/include/genfit/<a class="el" href="include_2genfit_2RKTrackRep_8h_source.html">RKTrackRep.h</a></li>
<li>genfit/trackReps/src/RKTrackRep.cc</li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.12
</small></address>
</body>
</html>
